'use strict';

const bis_genericio=require('bis_genericio');
const bis_util = require('bis_util.js');

// DICOM2BIDS
/**
 * Performs NII 2 Bids conversion of data generated by dcm2nii
 * @param {Dictionary} opts  - the parameter object
 * @param {String} opts.indir - the input directory (output of dcm2nii)
 * @param {String} opts.outdir - the output directory (output of this function)
 * @returns {Promise} -- when done with payload the list of converted files
 */
let dicom2BIDS=async function(opts)  {

    let errorfn=( (msg) => {
        console.log('Error=',msg);
        return msg;
    });

    let makeDir=async function(f) {
        try {
            await bis_genericio.makeDirectory(f);
        } catch(e) {
            if (e.code !== 'EEXIST') {
                errorfn('Error'+e);
                return false;
            } else {
                console.log('Directory Exists Ignoring');
            }
        }
        return true;
    };


    let indir=opts.indir || '';
    let outdir=opts.outdir || '';
    console.log('opts=',opts,indir,outdir);
    
    
    let matchniix=bis_genericio.joinFilenames(indir, '*.nii.gz');
    let matchsupp = bis_genericio.joinFilenames(indir, '*');
    
    let flist = await bis_genericio.getMatchingFiles(matchniix);
    let suppfiles = await bis_genericio.getMatchingFiles(matchsupp);

    console.log('Flist=',flist.join('\n\t'));
    console.log('supp files', suppfiles);

    //filter supplemental files by looking for files without '.nii'.
    //once you find a file and move it, record its name 
    let filteredsuppfiles = [], movedsuppfiles = [], suppmatch = undefined;
    for (let file of suppfiles) {
        if (!file.includes('.nii')) filteredsuppfiles.push(file);
    }

    if (flist.length<1) {
        return errorfn('No data to convert in '+indir);
    }
    
    let outputdirectory=bis_genericio.joinFilenames(outdir,'derived');
    try {
        await makeDir(outputdirectory);
    } catch (e) {
        return errorfn('Failed to make directory '+e);
    }

    console.log('+++++','Created directory',outputdirectory);

    let funcdir=bis_genericio.joinFilenames(outputdirectory,'func'); 
    let anatdir=bis_genericio.joinFilenames(outputdirectory,'anat'); 
    let locdir=bis_genericio.joinFilenames(outputdirectory,'localizer');
    let diffdir=bis_genericio.joinFilenames(outputdirectory,'diff'); 

    try {
        makeDir(funcdir);
        makeDir(anatdir);
        makeDir(diffdir);
        makeDir(locdir);
    } catch(e) {
        return errorfn('failed to make directory'+e);
    }
    
    let maxindex=flist.length;
    let tlist=[];
    for (let i=0;i<maxindex;i++) {

        let name=flist[i];
        let dirname=anatdir;
        let tname=name.toLowerCase();
        
        if (tname.indexOf('bold')>0 || tname.indexOf('asl')>0) {
            dirname=funcdir;
        } else if (tname.indexOf('localizer')>0) {
            dirname=locdir;
        } else if (tname.indexOf('.bval')>0 || tname.indexOf('.bvec')>0) {
            // DTI helper files
            dirname=diffdir;
        } else if (tname.indexOf('.nii.gz')>0) {
            let f2=name.substr(0,name.length-7);
            let f3=f2+'.bval';
            console.log(name,',',f2,'->',f3);
            if (flist.indexOf(f3)>=0)
                dirname=diffdir;
        }

        let origname=name;
        let basename=bis_genericio.getBaseName(name);
        
        let splitName = basename.split('.')[0];

        for (let suppfile of filteredsuppfiles) {
            //check if the trailing parts of one of the support files (without file type) match the image
            //strip out file extension and the name of the parent folder to match image
            let splitsupp = bis_genericio.getBaseName(suppfile).split('.');
            let filebasename = splitsupp[0];

            if (splitName.toLowerCase() === filebasename.toLowerCase()) {
                //rejoin file extension to the formatted splitsupp
                let suppTarget = bis_genericio.joinFilenames(dirname, bis_genericio.getBaseName(suppfile));
                movedsuppfiles.push(suppTarget);
                await bis_genericio.copyFile(suppfile + '&&' + suppTarget);
            }
        }

        let target=bis_genericio.joinFilenames(dirname,basename);
    
        try {
            await bis_genericio.copyFile(origname + '&&' + target);
        } catch (e) {
            return errorfn(e);
        }
        tlist.push(target);
    }
    
    //date will be a 14 character string in the middle of a filename
    let dateRegex = /\d{14}/g;
    let fileString = flist[0];
    let dateMatch = dateRegex.exec(fileString);
    let date = dateMatch[0];

    //separate date string into individual chunks
    let year = date.substring(0,4), month = date.substring(4,6), day = date.substring(6,8), hour = date.substring(8,10), minute = date.substring(10,12);
    
    let outfilename=bis_genericio.joinFilenames(outputdirectory,'dicom_job.json');
    let outobj = {
        "bisformat":"DICOMImport",
        "bidsversion": "1.1.0",
        "description": `DICOM Dataset generated on ${month}/${day}, ${year} at ${hour}:${minute}`,
        "job":[ ],
    };
    
    for (let i=0;i<tlist.length;i++) {
        let fname=tlist[i];
        let name=bis_genericio.getBaseName(tlist[i]);
        let infoname='';
        if (name.indexOf(".nii.gz")>0) {

            let tagname=bis_genericio.getBaseName(bis_genericio.getDirectoryName(fname));
            
            name=name.substr(0,name.length-7);
            let f2=fname.substr(0,fname.length-7)+'.bvec';
            let ind2=tlist.indexOf(f2);

            if (ind2>=0) {
                infoname=tlist[ind2];
                tagname="DTI";
            } else {
                if (tagname==='functional') {
                    tagname='Functional';
                } else if (tagname==='diffusion')  {
                    tagname='DTI';
                } else if (tagname==='anatomical') {
                    if (fname.indexOf('3D')>=0 || fname.indexOf('3d')> 0 ) {
                        tagname = '3DAnatomical';
                    } else {
                        tagname='Anatomical';
                    }
                } else {
                    tagname='None';
                }
            }
            
            //find supporting files from file list 
            let basename = name.split('.')[0], suppfileArray = [];
            for (let file of movedsuppfiles) {
                if (file.includes(basename)) {
                    let splitName = file.split('/'); 
                    console.log('basename', basename, 'tlist name', tlist[i], 'split name', splitName);
                    //parse the raw filename for only the BIDS components
                    //BIDS structuring should produce a filepath at least two entries long (BIDS subdirectory and filename), so if this isn't the case we want to let the user know
                    let bidsName = ( splitName.length >= 2 ? splitName.slice(splitName.length - 2, splitName.length).join('/') : 'Error: BIDS structure was not created correctly!');
                    suppfileArray.push(bidsName); 
                }
            }

            //create checksum for the image file
            //let filedata = await bis_genericio.read(tlist[i]);
            //console.log('filedata', filedata);
            //let hash = bis_util.SHA256(filedata);

            outobj.job.push({
                name : name,
                filename : fname.substr(outputdirectory.length+1,fname.length),
                tag : tagname,
                checksum : 'TODO: create this field!',
                supportingfiles: suppfileArray,
                details : infoname
            });

        }
    }
    
    try {
        await bis_genericio.write(outfilename,JSON.stringify(outobj,null,2),false);
    } catch(e) {
        return errorfn(e);
    }

    //delete input folder if it lives in /tmp
    let splitindir = indir.split('/');
    if (splitindir[0] === '') { splitindir.shift(); } //trim a leading slash if needs be
    if (splitindir[0] === 'tmp') {

        //remove the top level folder in /tmp
        let containingFolder = splitindir.splice(0, 2).join('/');
        containingFolder = '/' + containingFolder;
        bis_genericio.deleteDirectory(containingFolder).then( () => {
            console.log('Deleted', containingFolder, 'successfully');
        }).catch( (e) => {
            console.log('An Error occured trying to delete', containingFolder, e);
        });
    } 

    return outputdirectory;
    
};


module.exports = {
    dicom2BIDS : dicom2BIDS
};
