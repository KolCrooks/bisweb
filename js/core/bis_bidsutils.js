'use strict';

const bis_genericio = require('bis_genericio');
const colors=bis_genericio.getcolorsmodule();

//Need to keep track of labels to know if there are repeats, in which case they should be given a run number
let labelsMap = {};

// DICOM2BIDS
/**
 * Performs NII 2 Bids conversion on data generated by dcm2nii. 
 * When finished, the files will be placed in the specified output directory in a folder named 'source'. See BIDS specifications for more details on file structure. 
 * This function will also calculate checksums for each of the NIFI images before returning. This is to ensure data integrity. 
 * 
 * @param {Dictionary} opts  - the parameter object
 * @param {String} opts.indir - the input directory (output of dcm2nii)
 * @param {String} opts.outdir - the output directory (output of this function)
 * @returns {Promise} -- when done with payload the list of converted files
 */
let dicom2BIDS = async function (opts) {


    let errorfn = ((msg) => {
        console.log('Error=', msg);
        return msg;
    });

    let makeDir = async function (f) {
        try {
            console.log('making directory', f);
            await bis_genericio.makeDirectory(f);
        } catch (e) {
            if (e.code !== 'EEXIST') {
                errorfn('Error' + e);
                return false;
            } else {
                console.log('Directory Exists Ignoring');
            }
        }
        return true;
    };

    let indir = opts.indir || '';
    let outdir = opts.outdir || '';
    console.log('opts=', opts);

    let matchniix = bis_genericio.joinFilenames(indir, '*.nii.gz');
    let matchsupp = bis_genericio.joinFilenames(indir, '!(*.nii.gz)');

    let flist = await bis_genericio.getMatchingFiles(matchniix);
    let suppfiles = await bis_genericio.getMatchingFiles(matchsupp);

    console.log(colors.green('.... Flist : '+flist.join('\n\t')));
    console.log(colors.yellow('... Supporting files : '+suppfiles.join('\n\t')));

    let moveImageFiles = [], moveSupportingFiles = [];


    console.log('suppfiles', suppfiles);
    //filter supplemental files by looking for files without '.nii'.
    //once you find a file and move it, record its name 
    let filteredsuppfiles = [], movedsuppfiles = [];
    for (let file of suppfiles) {
        if (!file.includes('.nii')) filteredsuppfiles.push(file);
    }

    if (flist.length < 1) {
        return errorfn('No data to convert in ' + indir);
    }

    let outputdirectory = bis_genericio.joinFilenames(outdir, 'sourcedata');
    let subjectdirectory = bis_genericio.joinFilenames(outputdirectory,'sub-01');

    try {
        await makeDir(outputdirectory);
        await makeDir(subjectdirectory);
        console.log(colors.green('....\nCreated output directory : '+outputdirectory));
    } catch (e) {
        return errorfn('Failed to make directory ' + e);
    }


    let funcdir = bis_genericio.joinFilenames(subjectdirectory, 'func');
    let anatdir = bis_genericio.joinFilenames(subjectdirectory, 'anat');
    let locdir = bis_genericio.joinFilenames(subjectdirectory, 'localizer');
    let diffdir = bis_genericio.joinFilenames(subjectdirectory, 'dwi');

    try {
        await makeDir(funcdir);
        await makeDir(anatdir);
        await makeDir(diffdir);
        await makeDir(locdir);
    } catch (e) {
        return errorfn('failed to make directory' + e);
    }


    let maxindex = flist.length;
    let tlist = [], parsedFilenames = [];
    for (let i = 0; i < maxindex; i++) {

        let name = flist[i];
        let dirname = anatdir;
        let tname = name.toLowerCase();

        if (tname.indexOf('bold') > 0 || tname.indexOf('asl') > 0) {
            dirname = funcdir;
        } else if (tname.indexOf('localizer') > 0) {
            dirname = locdir;
        } else if (tname.indexOf('.bval') > 0 || tname.indexOf('.bvec') > 0) {
            // DTI helper files
            dirname = diffdir;
        } else if (tname.indexOf('.nii.gz') > 0) {
            let f2 = name.substr(0, name.length - 7);
            let f3 = f2 + '.bval';
            if (flist.indexOf(f3) >= 0)
                dirname = diffdir;
        }

        let origname = name;
        let basename = bis_genericio.getBaseName(name);
        let dirbasename = bis_genericio.getBaseName(dirname);

        console.log('name', name, '\n');
        let splitName = basename.split('.')[0];

        for (let suppfile of filteredsuppfiles) {
            //check if the trailing parts of one of the support files (without file type) match the image
            //strip out file extension and the name of the parent folder to match image
            let splitsupp = bis_genericio.getBaseName(suppfile).split('.');
            let filebasename = splitsupp[0];

            if (splitName.toLowerCase() === filebasename.toLowerCase()) {
                //rejoin file extension to the formatted splitsupp
                let suppBasename = bis_genericio.getBaseName(suppfile);
                let formattedSuppfile = makeBIDSFilename(suppBasename, dirbasename);
                let suppTarget = bis_genericio.joinFilenames(dirname, formattedSuppfile);

                movedsuppfiles.push(suppTarget);
                moveSupportingFiles.push(bis_genericio.copyFile(suppfile + '&&' + suppTarget));
            }
        }

        let formattedBasename = makeBIDSFilename(basename, dirbasename);
        let target = bis_genericio.joinFilenames(dirname, formattedBasename);
        parsedFilenames.push(target);

        try {
            moveImageFiles.push(bis_genericio.copyFile(origname + '&&' + target));
        } catch (e) {
            console.log('copy file', e);
            return errorfn(e);
        }
        tlist.push(target);
    }

    console.log('parsed filenames', parsedFilenames);
    let makeHash = calculateChecksums(parsedFilenames);

    //date will be a 14 character string in the middle of a filename
    let dateRegex = /\d{14}/g;
    let fileString = flist[0];
    let dateMatch = dateRegex.exec(fileString);
    let date = dateMatch[0];

    //separate date string into individual chunks
    let year = date.substring(0, 4), month = date.substring(4, 6), day = date.substring(6, 8), hour = date.substring(8, 10), minute = date.substring(10, 12);

    let dicomjobfilename = bis_genericio.joinFilenames(outputdirectory, 'dicom_job.json');
    let dicomobj = {
        "acquisition": 'DICOM',
        "bidsversion": "1.1.0",
        "description": `Dataset generated on ${month}/${day}, ${year} at ${hour}:${minute}`,
        "job": [],
    };

    for (let i = 0; i < tlist.length; i++) {
        let fname = tlist[i];
        let name = bis_genericio.getBaseName(fname);
        let infoname = '';
        if (name.indexOf(".nii.gz") > 0) {

            let tagname = bis_genericio.getBaseName(bis_genericio.getDirectoryName(fname));

            name = name.substr(0, name.length - 7);
            let f2 = fname.substr(0, fname.length - 7) + '.bvec';
            let ind2 = tlist.indexOf(f2);

            if (ind2 >= 0) {
                infoname = tlist[ind2];
                tagname = "DTI";
            } else {
                if (tagname === 'functional') {
                    tagname = 'Functional';
                } else if (tagname === 'diffusion') {
                    tagname = 'DTI';
                } else if (tagname === 'anatomical') {
                    if (fname.indexOf('3D') >= 0 || fname.indexOf('3d') > 0) {
                        tagname = '3DAnatomical';
                    } else {
                        tagname = 'Anatomical';
                    }
                } else {
                    tagname = 'None';
                }
            }

            //find supporting files from file list 
            let basename = name.split('.')[0], suppfileArray = [];
            for (let file of movedsuppfiles) {
                if (file.includes(basename)) {
                    let splitName = file.split('/');
                    //parse the raw filename for only the BIDS components
                    //BIDS structuring should produce a filepath at least two entries long (BIDS subdirectory and filename), so if this isn't the case we want to let the user know
                    let bidsName = (splitName.length >= 2 ? splitName.slice(splitName.length - 2, splitName.length).join('/') : 'Error: BIDS structure was not created correctly!');
                    suppfileArray.push(bidsName);
                }
            }

            dicomobj.job.push({
                name: name,
                filename: fname.substr(outputdirectory.length + 1, fname.length),
                tag: tagname,
                hash: 'TODO: fill this!',
                supportingfiles: suppfileArray,
                details: infoname
            });

        }
    }

    try {
        let promiseArray = Array.apply(moveImageFiles, moveSupportingFiles);

        let checksums = await makeHash;
        for (let prom of promiseArray) { await prom; }

        //let joinedPromiseArray = promiseArray.push(makeHash);
        //await Promise.all(joinedPromiseArray);

        //put checksums in dicom_job then write it to disk
        for (let val of checksums) {
            console.log('val', val);
            for (let fileEntry of dicomobj.job) {
                if (val.output.filename.includes(fileEntry.name)) {
                    fileEntry.hash = val.output.hash;
                    break;
                }
            }
        }

        await bis_genericio.write(dicomjobfilename, JSON.stringify(dicomobj, null, 2), false);
        console.log('----- output directory', outputdirectory);

        labelsMap = {};
        return outputdirectory;

    } catch (e) {
        labelsMap = {};
        return errorfn(e);
    }

    function makeBIDSFilename(filename, directory) {
        let splitsubdirectory = subjectdirectory.split('/');
        let fileExtension = filename.split('.');
        if (fileExtension.length > 2 && fileExtension[fileExtension.length - 2] === 'nii' && fileExtension[fileExtension.length - 1] === 'gz') {
            fileExtension = '.nii.gz';
        } else {
            fileExtension = '.' + fileExtension[fileExtension.length - 1];
        }

        //BIDS uses underscores as separator characters to show hierarchy in filenames, so change underscores to hyphens to avoid ambiguity
        filename = filename.split('_').join('-');

        let nameComponents = parseNameComponents(filename, directory), namesArray;

        let runNumber = getRunNumber(directory, nameComponents, fileExtension);
        if (directory === 'anat') {
            namesArray = [ splitsubdirectory[splitsubdirectory.length - 1], runNumber, nameComponents.modality];
        } else if (directory === 'func') {
            namesArray = [ splitsubdirectory[splitsubdirectory.length - 1], runNumber, nameComponents.contrast];
        }
        
        console.log(colors.green('BIDS filename', namesArray.join('_'), '\n'));
        let joinedName = namesArray.join('_');
        return joinedName.concat(fileExtension);
    }

    

    //Returns the number of runs with the same name name component for a directory type and updates the count in labelsMap (global map of keys seen so far)
    function getRunNumber(directoryType, nameComponents, fileExtension) {
        let runNum;
        //nameComponents will contain the name of the contrast agent for functional images and the imaging modality for anatomical
        if (directoryType === 'anat' || directoryType === 'anatomical') {
            runNum = checkLabelsMap('modality');
        } else if (directoryType === 'func' || directoryType === 'functional') {
            runNum = checkLabelsMap('contrast');
        }

        return runNum;
        
        function checkLabelsMap(key) {
            let num;
            if (labelsMap[nameComponents[key]]) {
                if (fileExtension.includes('nii')) { 
                    labelsMap[nameComponents[key]] = labelsMap[nameComponents[key]] + 1;
                    num = labelsMap[nameComponents[key]]; 
                } else {
                    num = labelsMap[nameComponents[key]];
                } 
            } else {
                labelsMap[nameComponents[key]] = 1;
                num = 1;
            }
            
            if (num < 10) { num = '0' + num;}
            return 'run-' + num;
        }
    }
};


/**
 * Calculates checksums for each of the NIFTI files in the BIDS directory.
 * 
 * @param {Array} inputFiles - Names of NIFTI files 
 * @returns Promise that will resolve once images have been checksummed.
 */
let calculateChecksums = (inputFiles) => {

    return new Promise((resolve, reject) => {
        let promises = [];
        for (let file of inputFiles) {
            promises.push(bis_genericio.makeFileChecksum(file));
        }

        Promise.all(promises)
            .then((values) => { console.log('done calculating checksums'); resolve(values); })
            .catch((e) => { reject(e); });
    });

};

/**
 * Parses name into a set of BIDS compliant name components. Currently only supports images acquired by MRI.
 * 
 * @param {String} name - Name of the file.
 * @param {String} directory - Name of the directory the file will be contained in, one of 'anat', 'func', 'diff', or 'localizer'   
 */
let parseNameComponents = (name, directory) => {
    let modLabel, contrastLabel; //TODO: add more labels? 
    name = name.toLowerCase();

    if (directory === 'anatomical' || directory === 'anat') {
        if (name.includes('t1') && name.includes('weight')) { modLabel = 'T1w'; }
        else if (name.includes('t2') && name.includes('weight')) { modLabel = 'T2w'; }
        else if (name.includes('t1') && name.includes('rho')) { modLabel = 'T1rho'; }
        else if (name.includes('t1') && name.includes('map')) { modLabel = 'T1map'; } 
        else if (name.includes('t1') && name.includes('plane')) { modLabel = 'inplaneT1'; }
        else if (name.includes('t2') && name.includes('map')) { modLabel = 'T2map'; }  
        else if (name.includes('t2') && name.includes('plane')) { modLabel = 'inplaneT2'; }
        else if (name.includes('star')) { modLabel = 'T2star'; }  
        else if (name.includes('flair')) { modLabel = 'FLAIR'; }
        else if (name.includes('flash')) { modLabel = 'FLASH'; }  
        else if (name.includes('pd') && name.includes('map')) { modLabel = 'PDmap'; }
        else if (name.includes('pd') && name.includes('t2')) { modLabel = 'PDT2'; } 
        else if (name.includes('pd')) { modLabel = 'PD'; }
        else if (name.includes('angio')) { modLabel = 'angio'; }
        else { modLabel = 'unknown'; }   
    }

    if (directory === 'functional' || directory === 'func') {
         //parse contrast label
        if (name.includes('bold')) { contrastLabel = 'bold'; }
        else if (name.includes('cbv')) {  contrastLabel = 'cbv'; }
        else if (name.includes('phase')) { contrastLabel = 'phase'; }
        else { contrastLabel = ''; }
    }

    console.log('mod label', modLabel, 'contrast label', contrastLabel, 'directory', directory);

    return {
        'contrast' : contrastLabel,
        'modality' : modLabel
    };
};


module.exports = {
    dicom2BIDS: dicom2BIDS
};
