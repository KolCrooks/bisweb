const genericio=require('bis_genericio');

// DICOM2BIDS
/**
 * Performs NII 2 Bids conversion of data generated by dcm2nii
 * @param {Dictionary} opts  - the parameter object
 * @param {String} opts.indir - the input directory (output of dcm2nii)
 * @param {String} opts.outdir - the output directory (output of this function)
 * @returns {Promise} -- when done with payload the list of converted files
 */
let dicom2BIDS=async function(opts)  {

    let errorfn=( (msg) => {
        console.log('Error=',msg);
        return msg;
    });

    let makeDir=async function(f) {
        try {
            await genericio.makeDirectory(f);
        } catch(e) {
            if (e.code !== 'EEXIST') {
                errorfn('Error'+e);
                return false;
            } else {
                console.log('Directory Exists Ignoring');
            }
        }
        return true;
    };


    let indir=opts.indir || '';
    let outdir=opts.outdir || '';
    console.log('opts=',opts,indir,outdir);
    
    
    let match=genericio.joinFilenames(indir,'2*.nii.gz');
    let matchdti=genericio.joinFilenames(indir,'*.bv*');
    
    console.log('Match=',match,matchdti);
    
    let flist= await genericio.getMatchingFiles(match);
    let flist2=await genericio.getMatchingFiles(matchdti);

    flist=flist.concat(flist2);
    console.log('Flist=',flist.join('\n\t'));

    
    if (flist.length<1) {
        return errorfn('No data to convert in '+indir);
    }

    let b=genericio.getBaseName(flist[0]).toLowerCase();
    
    let regex = /[a-z]/g;
    let ind=b.search(regex);
    if (ind<1) {
        return errorfn('Bad data to convert in '+indir);
    }
    
    let subjname=b.substr(0,ind-1);
    let outputdirectory=genericio.joinFilenames(outdir,subjname);
    try {
        await makeDir(outputdirectory);
    } catch (e) {
        return errorfn('Failed to make directory '+e);
    }

    console.log('+++++','Created directory',outputdirectory);

    let funcdir=genericio.joinFilenames(outputdirectory,'functional'); 
    let anatdir=genericio.joinFilenames(outputdirectory,'anatomical'); 
    let locdir=genericio.joinFilenames(outputdirectory,'localizer');
    let diffdir=genericio.joinFilenames(outputdirectory,'diffusion'); 

    try {
        makeDir(funcdir);
        makeDir(anatdir);
        makeDir(diffdir);
        makeDir(locdir);
    } catch(e) {
        return errorfn('failed to make directory'+e);
    }
    
    let maxindex=flist.length;
    let tlist=[];
    for (let i=0;i<maxindex;i++) {

        let name=flist[i];
        let dirname=anatdir;
        let tname=name.toLowerCase();
        
        if (tname.indexOf('bold')>0 || tname.indexOf('asl')>0) {
            dirname=funcdir;
        } else if (tname.indexOf('localizer')>0) {
            dirname=locdir;
        } else if (tname.indexOf('.bval')>0 || tname.indexOf('.bvec')>0) {
            // DTI helper files
            dirname=diffdir;
        } else if (tname.indexOf('.nii.gz')>0) {
            let f2=name.substr(0,name.length-7);
            let f3=f2+'.bval';
            console.log(name,',',f2,'->',f3);
            if (flist.indexOf(f3)>=0)
                dirname=diffdir;
        }

        let origname=name;

        let index=name.lastIndexOf('.');
        let mainname=name.substr(0,index-1);

        index=mainname.lastIndexOf('a');
        if (index>0) {
            name=name.substr(0,index)+'_'+name.substr(index,name.length);
        }


        index=name.lastIndexOf('s');
        if (index>0) {
            name=name.substr(0,index)+'_'+name.substr(index,name.length);
        }

        let basename=genericio.getBaseName(name).toLowerCase();
        index=basename.search(regex);
        console.log(index);
        if (index>0) {
            let l1=name.length;
            let l2=basename.length;
            index+=(l1-l2);
            name=name.substr(0,index)+'_'+name.substr(index,name.length);
        }
        
        let target=genericio.joinFilenames(dirname,genericio.getBaseName(name));
        console.log('+++++',index+', name=',origname,'-->',target);
        
        try {
            await genericio.copyFile(origname,target);
        } catch (e) {
            return errorfn(e);
        }
        tlist.push(target);
    }
        
    let outfilename=genericio.joinFilenames(outputdirectory,'dicom_job.json');
    let outobj = {
        "bisformat":"DICOMImport",
        "job":[ ],
    };
    
    for (let i=0;i<tlist.length;i++) {
        let fname=tlist[i];
        let name=genericio.getBaseName(tlist[i]);
        let infoname='';
        if (name.indexOf(".nii.gz")>0) {

            let tagname=genericio.getBaseName(genericio.getDirectoryName(fname));
            
            name=name.substr(0,name.length-7);
            let f2=fname.substr(0,fname.length-7)+'.bvec';
            let ind2=tlist.indexOf(f2);
            console.log('Looking for ',f2,ind2);
            if (ind2>=0) {
                infoname=tlist[ind2];
                tagname="DTI";
            } else {
                if (tagname==='functional') {
                    tagname='Functional';
                } else if (tagname==='diffusion')  {
                    tagname='DTI';
                } else if (tagname==='anatomical') {
                    if (fname.indexOf('3D')>=0 || fname.indexOf('3d')> 0 ) {
                        tagname = '3DAnatomical';
                    } else {
                        tagname='Anatomical';
                    }
                } else {
                    tagname='None';
                }
            }
            
            outobj.job.push({
                name : name,
                filename : fname.substr(outputdirectory.length+1,fname.length),
                tag : tagname,
                details : infoname
            });

        }
    }
    
    try {
        await genericio.write(outfilename,JSON.stringify(outobj,null,2),false);
    } catch(e) {
        return errorfn(e);
    }
    return outfilename;
       
};


module.exports = {
    dicom2BIDS : dicom2BIDS
};
