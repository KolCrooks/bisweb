const genericio=require('bis_genericio');

// DICOM2BIDS
/**
 * Performs NII 2 Bids conversion of data generated by dcm2nii
 * @param {Dictionary} opts  - the parameter object
 * @param {String} opts.indir - the input directory (output of dcm2nii)
 * @param {String} opts.outdir - the output directory (output of this function)
 * @returns {Promise} -- when done with payload the list of converted files
 */
let dicom2BIDS=async function(opts)  {

    let errorfn=( (msg) => {
        console.log('Error=',msg);
        return msg;
    });

    let makeDir=async function(f) {
        try {
            await genericio.makeDirectory(f);
        } catch(e) {
            if (e.code !== 'EEXIST') {
                errorfn('Error'+e);
                return false;
            } else {
                console.log('Directory Exists Ignoring');
            }
        }
        return true;
    };


    let indir=opts.indir || '';
    let outdir=opts.outdir || '';
    console.log('opts=',opts,indir,outdir);
    
    
    let match=genericio.joinFilenames(indir,'2*.nii.gz');
    let matchuncompressed = genericio.joinFilenames(indir, '2*.nii');
    let matchniix=genericio.joinFilenames(indir, 'sourcedata*.nii.gz');
    let matchsupp = genericio.joinFilenames(indir, '*');
    
    console.log('Match=',match);
    
    let flist = await genericio.getMatchingFiles(match);
    let flist2 = await genericio.getMatchingFiles(matchuncompressed);
    let flist3 = await genericio.getMatchingFiles(matchniix);
    let suppfiles = await genericio.getMatchingFiles(matchsupp);

    flist=flist.concat(flist2);
    flist=flist.concat(flist3);
    console.log('Flist=',flist.join('\n\t'));

    //filter supplemental files by looking for files without '.nii'. outer capture group will have the full name of the file
    let suppFilter = /^((?!.\.nii).)*$/gm, filteredsuppfiles = [], suppmatch = undefined;
    for (let file of suppfiles) {
        suppmatch = suppFilter.exec(file);
        if (suppmatch) filteredsuppfiles.push(suppmatch[0]);
    }
    
    console.log('filteredsuppfiles', filteredsuppfiles);

    if (flist.length<1) {
        return errorfn('No data to convert in '+indir);
    }
    
    let outputdirectory=genericio.joinFilenames(outdir,'derived');
    try {
        await makeDir(outputdirectory);
    } catch (e) {
        return errorfn('Failed to make directory '+e);
    }

    console.log('+++++','Created directory',outputdirectory);

    let funcdir=genericio.joinFilenames(outputdirectory,'func'); 
    let anatdir=genericio.joinFilenames(outputdirectory,'anat'); 
    let locdir=genericio.joinFilenames(outputdirectory,'localizer');
    let diffdir=genericio.joinFilenames(outputdirectory,'diff'); 

    try {
        makeDir(funcdir);
        makeDir(anatdir);
        makeDir(diffdir);
        makeDir(locdir);
    } catch(e) {
        return errorfn('failed to make directory'+e);
    }
    
    let maxindex=flist.length;
    let tlist=[];
    for (let i=0;i<maxindex;i++) {

        let name=flist[i];
        let dirname=anatdir;
        let tname=name.toLowerCase();
        
        if (tname.indexOf('bold')>0 || tname.indexOf('asl')>0) {
            dirname=funcdir;
        } else if (tname.indexOf('localizer')>0) {
            dirname=locdir;
        } else if (tname.indexOf('.bval')>0 || tname.indexOf('.bvec')>0) {
            // DTI helper files
            dirname=diffdir;
        } else if (tname.indexOf('.nii.gz')>0) {
            let f2=name.substr(0,name.length-7);
            let f3=f2+'.bval';
            console.log(name,',',f2,'->',f3);
            if (flist.indexOf(f3)>=0)
                dirname=diffdir;
        }

        let origname=name;
        let basename=genericio.getBaseName(name).toLowerCase();

        let regex = /[A-Za-z0-9]*_(.*)/g;
        let regexMatch = regex.exec(basename);

        name = regexMatch[1];
        let splitName = name.split('.')[0];

        for (let suppfile of filteredsuppfiles) {
            //check if the trailing parts of one of the support files (without file type) match the image
            //strip out file extension and the name of the parent folder to match image
            let splitsupp = genericio.getBaseName(suppfile).split('.');
            let splitbasename = splitsupp[0].split('_');
            splitbasename.shift();
            let suppcomparename = splitbasename.join('_');

            
            if (splitName === suppcomparename) {
                console.log('found match for', splitName);
                //rejoin file extension to the formatted splitsupp
                splitsupp[0] = suppcomparename;
                let suppname = splitsupp.join('.');
                let suppTarget = genericio.joinFilenames(dirname, genericio.getBaseName(suppname));
                await genericio.copyFile(suppfile + '&&' + suppTarget);
            }
        }

        let target=genericio.joinFilenames(dirname,genericio.getBaseName(name));
    
        try {
            await genericio.copyFile(origname + '&&' + target);
        } catch (e) {
            return errorfn(e);
        }
        tlist.push(target);
    }
    
    //date will be a 14 character string in the middle of a filename
    let dateRegex = /\d{14}/g;
    let fileString = flist[0];
    let dateMatch = dateRegex.exec(fileString);
    let date = dateMatch[0];

    //separate date string into individual chunks
    let year = date.substring(0,4), month = date.substring(4,6), day = date.substring(6,8), hour = date.substring(8,10), minute = date.substring(10,12);
    
    let outfilename=genericio.joinFilenames(outputdirectory,'dicom_job.json');
    let outobj = {
        "bisformat":"DICOMImport",
        "bidsversion": "1.1.0",
        "description": `DICOM Dataset generated on ${month}/${day}, ${year} at ${hour}:${minute}`,
        "job":[ ],
    };
    
    for (let i=0;i<tlist.length;i++) {
        let fname=tlist[i];
        let name=genericio.getBaseName(tlist[i]);
        let infoname='';
        if (name.indexOf(".nii.gz")>0) {

            let tagname=genericio.getBaseName(genericio.getDirectoryName(fname));
            
            name=name.substr(0,name.length-7);
            let f2=fname.substr(0,fname.length-7)+'.bvec';
            let ind2=tlist.indexOf(f2);
            console.log('Looking for ',f2,ind2);
            if (ind2>=0) {
                infoname=tlist[ind2];
                tagname="DTI";
            } else {
                if (tagname==='functional') {
                    tagname='Functional';
                } else if (tagname==='diffusion')  {
                    tagname='DTI';
                } else if (tagname==='anatomical') {
                    if (fname.indexOf('3D')>=0 || fname.indexOf('3d')> 0 ) {
                        tagname = '3DAnatomical';
                    } else {
                        tagname='Anatomical';
                    }
                } else {
                    tagname='None';
                }
            }
            
            outobj.job.push({
                name : name,
                filename : fname.substr(outputdirectory.length+1,fname.length),
                tag : tagname,
                details : infoname
            });

        }
    }
    
    try {
        await genericio.write(outfilename,JSON.stringify(outobj,null,2),false);
    } catch(e) {
        return errorfn(e);
    }
    return outfilename;
    
};


module.exports = {
    dicom2BIDS : dicom2BIDS
};
