'use strict';

const bis_genericio = require('bis_genericio');
const colors=bis_genericio.getcolorsmodule();
const fs = bis_genericio.getfsmodule();

//Need to keep track of labels to know if there are repeats, in which case they should be given a run number
let labelsMap = {};

const dicomParametersFilename = 'dicom_job_info.json';
const sourceDirectoryName = 'sourcedata';

//This is a transient copy of the dicom_job_info.json file that gets created when parsing JSON to BIDS. 
//Some operations the user does will modify the file tree, so we want to update dicom_job_info.json with it to ensure it's up to date. 
//This will get written back to disk about every minute.
let transientDicomJobInfo = null;
let scheduledWriteback = null;

// DICOM2BIDS
/**
 * Performs NII 2 Bids conversion on data generated by dcm2nii. 
 * When finished, the files will be placed in the specified output directory in a folder named 'source'. See BIDS specifications for more details on file structure. 
 * This function will also calculate checksums for each of the NIFI images before returning. This is to ensure data integrity. 
 * 
 * @param {Dictionary} opts  - the parameter object
 * @param {String} opts.indir - the input directory (output of dcm2nii)
 * @param {String} opts.outdir - the output directory (output of this function)
 * @returns {Promise} -- when done with payload the list of converted files
 */
let dicom2BIDS = async function (opts) {


    let errorfn = ((msg) => {
        console.log('Error=', msg);
        return msg;
    });

    let makeDir = async function (f) {
        try {
            console.log('making directory', f);
            await bis_genericio.makeDirectory(f);
        } catch (e) {
            if (e.code !== 'EEXIST') {
                errorfn('Error' + e);
                return false;
            } else {
                console.log('Directory Exists Ignoring');
            }
        }
        return true;
    };

    let indir = opts.indir || '';
    let outdir = opts.outdir || '';
    console.log('opts=', opts);

    //read size of directory to determine whether or not to calculate checksums
    let total = await readSizeRecursive(indir) / 1024 / 1024 / 1024; //convert to gigabytes

    let calcHash = true;
    if ( total > 2) { console.log('study too large to parse checksums, skipping'); calcHash = false; }

    console.log(colors.red('total', total));

    let matchniix = bis_genericio.joinFilenames(indir, '*(*.nii.gz|*.nii)');
    let matchsupp = bis_genericio.joinFilenames(indir, '!(*.nii.gz|*.nii)');

    let flist = await bis_genericio.getMatchingFiles(matchniix);
    let suppfiles = await bis_genericio.getMatchingFiles(matchsupp);

    console.log(colors.green('.... Flist : '+flist.join('\n\t')));
    console.log(colors.yellow('... Supporting files : '+suppfiles.join('\n\t')));

    //Promise arrays
    let moveImageFiles = [], moveSupportingFiles = [];
    let changedNames = [];

    if (flist.length < 1) {
        return errorfn('No data to convert in ' + indir);
    }

    let outputdirectory = bis_genericio.joinFilenames(outdir, sourceDirectoryName);
    let subjectdirectory = bis_genericio.joinFilenames(outputdirectory,'sub-01');

    try {
        await makeDir(outputdirectory);
        await makeDir(subjectdirectory);
        console.log(colors.green('....\nCreated output directory : '+outputdirectory));
    } catch (e) {
        return errorfn('Failed to make directory ' + e);
    }


    let funcdir = bis_genericio.joinFilenames(subjectdirectory, 'func');
    let anatdir = bis_genericio.joinFilenames(subjectdirectory, 'anat');
    let locdir = bis_genericio.joinFilenames(subjectdirectory, 'localizer');
    let diffdir = bis_genericio.joinFilenames(subjectdirectory, 'dwi');

    try {
        await makeDir(funcdir);
        await makeDir(anatdir);
        await makeDir(diffdir);
        await makeDir(locdir);
    } catch (e) {
        return errorfn('failed to make directory' + e);
    }


    let maxindex = flist.length;
    //name arrays
    let tlist = [], parsedFilenames = [], movedsuppfiles = [];
    for (let i = 0; i < maxindex; i++) {

        let name = flist[i];
        let dirname = anatdir;
        let tname = name.toLowerCase();

        if (tname.includes('bold') || tname.includes('asl') || tname.includes('rest') || tname.includes('task')) {
            dirname = funcdir;
        } else if (tname.includes('localizer') || tname.includes('loc')) {
            dirname = locdir;
        } else if (tname.includes('.bval') || tname.includes('.bvec')) {
            // DTI helper files
            dirname = diffdir;
        } else if (tname.includes('dti') || tname.includes('dwi') || tname.includes('diff')) {
            dirname = diffdir;
        } else if (tname.includes('.nii.gz')) {
            let f2 = name.substr(0, name.length - 7);
            let f3 = f2 + '.bval';
            if (flist.includes(f3))
                dirname = diffdir;
        }

        let origname = name;
        let basename = bis_genericio.getBaseName(name);
        let dirbasename = bis_genericio.getBaseName(dirname);

        console.log('name', name, '\n');
        let splitName = basename.split('.')[0];

        let filteredsuppfiles = suppfiles.filter( (file) => {
            return file.toLowerCase().includes(splitName.toLowerCase());
        });

        for (let suppfile of filteredsuppfiles) {
            let suppBasename = bis_genericio.getBaseName(suppfile);
            let formattedSuppfile = makeBIDSFilename(suppBasename, dirbasename);
            let suppTarget = bis_genericio.joinFilenames(dirname, formattedSuppfile);

            if (!formattedSuppfile.includes('DISCARD')) {
                movedsuppfiles.push(suppTarget);
                changedNames.push(bis_genericio.getBaseName(suppfile) + ' -> ' + bis_genericio.getBaseName(suppTarget));
                moveSupportingFiles.push(bis_genericio.copyFile(suppfile + '&&' + suppTarget));
            }
        }


        let formattedBasename = makeBIDSFilename(basename, dirbasename);
        let target = bis_genericio.joinFilenames(dirname, formattedBasename);

        console.log('formatted base name', formattedBasename);
        if (!formattedBasename.includes('DISCARD')) {
            parsedFilenames.push(target);

            changedNames.push(bis_genericio.getBaseName(origname) + ' -> ' + bis_genericio.getBaseName(target));
            moveImageFiles.push(bis_genericio.copyFile(origname + '&&' + target));
            tlist.push(target);
        } 
    }



    console.log('parsed filenames', parsedFilenames);
    let makeHash = ( calcHash ? calculateChecksums(parsedFilenames) : [ Promise.resolve()]);


    //date will be a 14 character string in the middle of a filename
    let dateRegex = /\d{14}/g;
    let fileString = flist[0];
    let dateMatch = dateRegex.exec(fileString);
    let date = dateMatch[0];

    //separate date string into individual chunks
    let year = date.substring(0, 4), month = date.substring(4, 6), day = date.substring(6, 8), hour = date.substring(8, 10), minute = date.substring(10, 12);

    let dicomobj = {
        "acquisition": 'DICOM',
        "bidsversion": "1.1.0",
        "description": `Dataset generated on ${month}/${day}, ${year} at ${hour}:${minute}`,
        "files": [],
    };

    for (let i = 0; i < tlist.length; i++) {
        let fname = tlist[i];
        let name = bis_genericio.getBaseName(fname);
        let infoname = '';
        if (name.includes(".nii.gz")) {

            let tagname = bis_genericio.getBaseName(bis_genericio.getDirectoryName(fname));

            name = name.substr(0, name.length - 7);
            let f2 = fname.substr(0, fname.length - 7) + '.bvec';
            let ind2 = tlist.indexOf(f2);

            if (ind2 >= 0) {
                infoname = tlist[ind2];
                tagname = "DTI";
            } else {
                if (tagname === 'functional') {
                    tagname = 'Functional';
                } else if (tagname === 'diffusion') {
                    tagname = 'DTI';
                } else if (tagname === 'anatomical') {
                    if (fname.includes('3D') || fname.includes('3d')) {
                        tagname = '3DAnatomical';
                    } else {
                        tagname = 'Anatomical';
                    }
                } else {
                    tagname = 'None';
                }
            }

            //find supporting files from file list 
            let basename = name.split('.')[0], suppfileArray = [];
            for (let file of movedsuppfiles) {
                if (file.includes(basename)) {
                    suppfileArray.push(file.substr(outputdirectory.length + 1, file.length));
                }
            }

            dicomobj.files.push({
                name: name,
                filename: fname.substr(outputdirectory.length + 1, fname.length),
                tag: tagname,
                hash: 'no checksums',
                supportingfiles: suppfileArray,
                details: infoname
            });

        }
    }

    try {
        let promiseArray = Array.apply(moveImageFiles, moveSupportingFiles);

        let checksums = await makeHash;
        for (let prom of promiseArray) { await prom; }

        //put checksums in dicom_job then write it to disk (if checksums have been calculated)
        if (calcHash) {
            for (let val of checksums) {
                console.log('val', val);
                for (let fileEntry of dicomobj.job) {
                    if (val.output.filename.includes(fileEntry.name)) {
                        fileEntry.hash = val.output.hash;
                        break;
                    }
                }
            }
        }
       

        let bidsignore = '**/localizer\n**/dicom_job_info.json\n**/name_change_log.txt';

        let date = new Date();
        date = new Date().toLocaleDateString() + ' at ' + date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds();
        let datasetDescription = {
            'Name' : 'DICOM dataset converted on ' + date,
            'BIDSVersion': "1.2.0",
            "License" : "",
            "Authors" : [],
            "Funding" : []
        };
        
        //write record of name changes to disk
        let namechangefilename = bis_genericio.joinFilenames(outputdirectory, 'name_change_log.txt');
        let bidsignorefilename = bis_genericio.joinFilenames(outputdirectory, '.bidsignore');
        let dicomjobfilename = bis_genericio.joinFilenames(outputdirectory, dicomParametersFilename);
        let datasetdescriptionfilename = bis_genericio.joinFilenames(outputdirectory, 'dataset_description.json');

        await bis_genericio.write(namechangefilename, changedNames.join('\n'), false);
        await bis_genericio.write(bidsignorefilename, bidsignore, false);
        await bis_genericio.write(dicomjobfilename, JSON.stringify(dicomobj, null, 2), false);
        await bis_genericio.write(datasetdescriptionfilename, JSON.stringify(datasetDescription, null, 2), false);
        console.log('----- output directory', outputdirectory);

        labelsMap = {};
        return outputdirectory;

    } catch (e) {
        labelsMap = {};
        return errorfn(e);
    }

    function makeBIDSFilename(filename, directory) {
        let splitsubdirectory = subjectdirectory.split('/');
        let fileExtension = filename.split('.');
        if (fileExtension.length > 2 && fileExtension[fileExtension.length - 2] === 'nii' && fileExtension[fileExtension.length - 1] === 'gz') {
            fileExtension = '.nii.gz';
        } else {
            fileExtension = '.' + fileExtension[fileExtension.length - 1];
        }

        //BIDS uses underscores as separator characters to show hierarchy in filenames, so change underscores to hyphens to avoid ambiguity
        filename = filename.split('_').join('-');

        let bidsLabel = parseBIDSLabel(filename, directory), namesArray;
        let runNumber = getRunNumber(bidsLabel, fileExtension);

        //may change in the future, though currently looks a bit more specific than needed
        if (directory === 'anat') {
            namesArray = [ splitsubdirectory[splitsubdirectory.length - 1], runNumber, bidsLabel];
        } else if (directory === 'func') {
            namesArray = [ splitsubdirectory[splitsubdirectory.length - 1], 'task-unnamed', runNumber, bidsLabel];
        } else if (directory === 'localizer') {
            namesArray = [ splitsubdirectory[splitsubdirectory.length - 1], runNumber, bidsLabel];
        } else if (directory === 'dwi') {
            namesArray = [ splitsubdirectory[splitsubdirectory.length - 1], runNumber, bidsLabel];
        }
        
        console.log(colors.green('BIDS filename', namesArray.join('_'), '\n'));
        let joinedName = namesArray.join('_');
        return joinedName.concat(fileExtension);
    }

    

    //Returns the number of runs with the same name name component for a directory type and updates the count in labelsMap (global map of keys seen so far)
    function getRunNumber(bidsLabel, fileExtension) {
        let runNum;
        
        if (labelsMap[bidsLabel]) {
            if (fileExtension.includes('nii')) {
                //supporting files are moved before the image file in the code above
                //so once we find the image we can safely increment the label in labelsMap
                runNum = labelsMap[bidsLabel];
                labelsMap[bidsLabel] = labelsMap[bidsLabel] + 1;
            } else {
                runNum = labelsMap[bidsLabel];
            }
        } else {
            labelsMap[bidsLabel] = 1;
            runNum = 1;
        }

        if (runNum < 10) { runNum = '0' + runNum; }
        return 'run-' + runNum; 
    }
};

/**
 * Makes supporting files match the format of their parent image files which have been changed by another operation.
 * Call this function after image files have been altered in some way, e.g. by a user changing where files are in the file tree. 
 * 
 * @param {Array} changedFiles - Names of files that have already been moved. Each entry is an object with a field 'old' that has the old name of the image and 'new' with the changed name. These should be the full paths for the files. 
 * @param {String} baseDirectory - Name of the base directory of the study. 
 */
let syncSupportingFiles = (changedFiles, baseDirectory) => {

    //dicom params file is in source so trim base directory to there
    let splitFilename = baseDirectory.split('/');
    for (let i = 0; i < splitFilename.length; i++) { 
        if (splitFilename[i] === sourceDirectoryName) { 
            baseDirectory = splitFilename.slice(0, i + 1).join('/'); 
            i = splitFilename.length; 
        }
    }

    let settingsFilename = baseDirectory + '/' + dicomParametersFilename;

    //open dicom settings file 
    getSettingsFile(settingsFilename).then( (settings) => {

        for (let file of changedFiles) {

            let oldFilename = bis_genericio.getBaseName(file.old);
            oldFilename = oldFilename.split('.')[0];

            for (let i = 0; i < settings.files.length; i++) {

                let settingsFilename = settings.files[i].name;
                if (settingsFilename.includes(oldFilename)) {
                    let supportingFiles = settings.files[i].supportingfiles;

                    //new supporting file list for writeback
                    let newSupportingFileList = [];
                    for (let supportingFile of supportingFiles) {

                        //file extension could be in two parts, e.g. like '.nii.gz' 
                        let fileExtension = bis_genericio.getBaseName(supportingFile).split('.');
                        if (fileExtension.length > 2) { fileExtension = fileExtension.slice(1).join('.'); }
                        else { fileExtension = fileExtension[1]; }

                        //construct the full name of the destination using the new location of the image
                        let newFilename = bis_genericio.getBaseName(file.new).split('.')[0];
                        let newFilepath = file.new.split('/');
                        newFilepath = newFilepath.slice(0, newFilepath.length - 1);
                        newFilepath.push(newFilename + '.' + fileExtension);
                        newFilepath = newFilepath.join('/');
                        
                        //file.old will hold the old location of the image, so trim off the file extension and add the extension of the supporting file to get its location
                        let splitOldPath = file.old.split('/');
                        splitOldPath[splitOldPath.length - 1] = splitOldPath[splitOldPath.length - 1].split('.')[0] + '.' + fileExtension;
                        let oldFilepath = splitOldPath.join('/');

                        console.log('old location', oldFilepath, 'new location', newFilepath);

                        bis_genericio.moveDirectory(oldFilepath + '&&' + newFilepath);
                        newSupportingFileList.push(newFilepath);
                    }

                    //'name' should be the base filename without an extension, 'filename' and 'supportingfiles' should be the last three files in the path (the location within the bids directory)
                    let splitNewPath = file.new.split('/');
                    for (let i = 0; i < newSupportingFileList.length; i++) {
                        let splitSuppPath = newSupportingFileList[i].split('/');
                        newSupportingFileList[i] = splitSuppPath.slice(splitSuppPath.length - 3).join('/');
                    }

                    let filename = splitNewPath.slice(splitNewPath.length - 3).join('/');
                    let name = splitNewPath.slice(splitNewPath.length - 1);
                    name = name[0].split('.')[0];

                    let settingsEntry = settings.files[i];
                    settingsEntry.name = name; 
                    settingsEntry.filename = filename;
                    settingsEntry.supportingfiles = newSupportingFileList;

                }
            }
        }

        console.log('new settings', settings);
        scheduleWriteback(settingsFilename, settings);

    });


};


/**
 * Determines whether the dicom settings file (dicom_job_info.json) needs to be read from disk then returns the result. 
 * Note that currently this should only have to read from disk the first time.
 * 
 * @param {String} filename - Location of the settings file on disk. Note that this is only optional to account for the case where you know the settings file is in memory.
 */
let getSettingsFile = (filename = '') => {
    return new Promise( (resolve, reject) => {
        if (transientDicomJobInfo !== null) {
            resolve(transientDicomJobInfo);
        }

        bis_genericio.read(filename).then( (obj) => {
            try {   
                let parsedSettings = JSON.parse(obj.data);
                console.log('settings', parsedSettings);
                transientDicomJobInfo = parsedSettings;
                resolve(transientDicomJobInfo);
            } catch(e) {
                reject(e);
            }
        }).catch( (e) => { reject(e); });
    });
};

/**
 * Schedules a disk write for a time after this function is called. Note that this function may not save the file passed to the function by 'settings' initially.
 * It will save the latest copy passed to the function before the write is triggered. 
 * 
 * @param {String} filename - Name of the settings file to save.
 * @param {Object} settings - New settings file to write over transientDicomJobInfo.
 */
let scheduleWriteback = (filename, settings) => {
    transientDicomJobInfo = settings;

    let writebackFn = () => {
        let currentInfo = getJobInfo(); 
        let writebackFile = JSON.stringify(currentInfo, null, 2);
        bis_genericio.write(filename, writebackFile, false);
        scheduledWriteback = null;
    };

    if (!scheduledWriteback) {
        scheduledWriteback = setTimeout(writebackFn, 60000);
    }

    //fire event if window is closed too
    if (window) {
        window.addEventListener('beforeunload', () => {
            writebackFn();
        });
    }
};

/**
 * Calculates checksums for each of the NIFTI files in the BIDS directory.
 * 
 * @param {Array} inputFiles - Names of NIFTI files 
 * @returns Promise that will resolve once images have been checksummed.
 */
let calculateChecksums = (inputFiles) => {

    return new Promise((resolve, reject) => {
        let promises = [];
        for (let file of inputFiles) {
            promises.push(bis_genericio.makeFileChecksum(file));
        }

        Promise.all(promises)
            .then((values) => { console.log('done calculating checksums'); resolve(values); })
            .catch((e) => { reject(e); });
    });

};

/**
 * Parses name into a set of BIDS compliant name components. Currently only supports images acquired by MRI.
 * 
 * @param {String} name - Name of the file.
 * @param {String} directory - Name of the directory the file will be contained in, one of 'anat', 'func', 'diff', or 'localizer'   
 */
let parseBIDSLabel = (name, directory) => {
    let bidsLabel;
    name = name.toLowerCase();

    //some files should not be propagated, so simply indicate to discard them
    if (name.includes('phoenix') && name.includes('document')) {
        return 'DISCARD';
    }

    if (directory === 'anatomical' || directory === 'anat') {
        if ( (name.includes('t1') && name.includes('weight') ) || name.includes('mprage') || name.includes('t1w')) { bidsLabel = 'T1w'; }
        else if (name.includes('t2') && name.includes('weight')) { bidsLabel = 'T2w'; }
        else if (name.includes('t1') && name.includes('rho')) { bidsLabel = 'T1rho'; }
        else if (name.includes('t1') && name.includes('map')) { bidsLabel = 'T1map'; } 
        else if (name.includes('t1') && name.includes('plane')) { bidsLabel = 'inplaneT1'; }
        else if (name.includes('t2') && name.includes('map')) { bidsLabel = 'T2map'; }  
        else if (name.includes('t2') && name.includes('plane')) { bidsLabel = 'inplaneT2'; }
        else if (name.includes('star')) { bidsLabel = 'T2star'; }  
        else if (name.includes('flair')) { bidsLabel = 'FLAIR'; }
        else if (name.includes('flash')) { bidsLabel = 'FLASH'; }  
        else if (name.includes('pd') && name.includes('map')) { bidsLabel = 'PDmap'; }
        else if (name.includes('pd') && name.includes('t2')) { bidsLabel = 'PDT2'; } 
        else if (name.includes('pd')) { bidsLabel = 'PD'; }
        else if (name.includes('angio')) { bidsLabel = 'angio'; }
        else { bidsLabel = 'unknown'; }   
    }

    if (directory === 'functional' || directory === 'func') {
        //parse contrast label
        if (name.includes('bold')) { bidsLabel = 'bold'; }
        else if (name.includes('cbv')) {  bidsLabel = 'cbv'; }
        else if (name.includes('phase')) { bidsLabel = 'phase'; }
        else { bidsLabel = 'unknown'; }
    }

    if (directory === 'localizer') {
        //trim number at the end of the localizer to use as the label
        let splitName = name.split('-');
        bidsLabel = splitName[splitName.length - 1];

        //split off the file extension too
        let trimmedLabel = bidsLabel.split('.');
        bidsLabel = trimmedLabel[0];
    }

    if (directory === 'dwi' || directory === 'diff') {
        bidsLabel = 'dwi';
    }

    return bidsLabel;
};

/**
 * Recursively reads the size of a directory (by reading the size of all its contents).
 * 
 * @param {String} item - The name of the root directory when invoking 
 */
let readSizeRecursive = (filepath) => {
    return new Promise( (resolve, reject) => {
        fs.lstat(filepath, (err, stats) => {
            if (err) { console.log('err', err); reject(err); return; }
            if (stats.isDirectory()) {
                let total = stats.size;

                fs.readdir(filepath, (err, children) => {
                    if (err) { reject(err); }

                    let reads = [];
                    for (let child of children) {
                        reads.push(readSizeRecursive([filepath, child].join('/')));
                    }

                    Promise.all(reads).then( (values) => {

                        for (let value of values) { total = total + value; }
                        resolve(total);
                    });
                });
    
                
            } else {
                resolve(stats.size);
            }
        });
    }).catch( (err) => {
        console.log('Read size recursive encountered an error', err); 
    });
};

/**
 * Returns transientDicomJobInfo. Necessary because otherwise scheduleWriteback will bind the most recent version of transientDicomJobInfo at the first time it's called and won't check for the most recent version.
 */
let getJobInfo = () => {
    return transientDicomJobInfo;
};


module.exports = {
    dicom2BIDS: dicom2BIDS,
    syncSupportingFiles : syncSupportingFiles,
    getSettingsFile : getSettingsFile
};
